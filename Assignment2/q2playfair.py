from itertools import izip, islice
import copy, math, random

CIPHER_TEXT = "ODCZCEIZWYEHDXZESNDXESWYEHDXKZVHISEZVHEBDENZWGZFWXERMENTEHSMWMANDXZEDEFWBZHNNSHAZCELFEGCCVDHEKRISCCHGLKZCLZYVHYBVHDHCFHTUYHZWGCESNNYZEIUCVMSRIMLDEYKRIMLDEVHKAHVRINYUDLHEHLXKXHTXYNHZUBHWTXZNWFZNHSMDEUHNSLMMCEIXLBLVHRYMOAFGXMUMGCZOLKQXVHTZDNHDXVHOLAQODDCSNSEZQHEDKEHANDXXFZSXLBLMENYKWUXSEDXSNANBANSFWBZODDCMSCSXLBLEZTKUXKFXHVTHBDCFEMEEKCNKSHEGQCLKNZUZUCHFNCRLXXZVEUZPYODNWQCMSHDZKMEEVMSKIZCCDQZWUDVRNWZNMBLVHFALFBWHLCHSNYBVHBLMLRIMEEBFSHEWZNMBLODNSCESNLXSNLOODNALXSNGLGVVHEVMSKIHTXBXFDZELDXVHOYUZELZBZTZBYSHEZQWZNMBLWTXGCEHXSWUXKFDZVHSNMSHVXVNKHEZSXLBLBLKDDZWLZQMEEKDKODCRXYANWZNMBLZCNCVMEZODDCSHHELOROSHMSMENTEHQCMCSMMOMFPMDOWZNMBLLGMFPMDOWZNMBLAGZQZDSNENNSHXDEXQFADCHTBKUXNHBLEHWTXQWURIXYWLCVFZWZNMBLZEYNELXMKIWZNMBLADSEZQHZEINCARHNHDZDHDWZNMBLLGHLKOVHBNCEODCEZDKFWZNMBLEHANDXXFZSXLBLBLKDNZHNHDRISHXRFWYWNLCEEREHBELTNYCZHDWEMEZDYDCBEBKSPYAEKNPYMOGACEAGDZLORIYKUXMEHYWMAWNSZBRIBWBZZBYSWTTVUZMENYKWUXSNANBANSODHAEZZTXYANWTXZXRHEZUUXXKXVPYAEKNZSXLBLYXNWDRWTOGGLMQNZDCUXDHHEVHGWHTZTODNSHCEZLAXRHSRCAHEINCHINWWEODHECRZBDXCSWLLOELMQYNRAEZNWVMHTIHLCUTTHHDQKXHBYUTXFZCNAHEZUSNNHKMNSBZDZNFUXLVODNCDXNSNHIRVMCDMSKEUZGZDXCVZXIRLCEZHLTFRIMLZXEIAHNHXIXHVTHBDCCLRZKZMSRIMLODMSKIHTOKRILGBWXVWAHNNSHXDMGOKXHEUXZYXLBLGTOYELZBLTXZBIFLKSFWBZLAUXBYTVAHCKZSWLLHYNXHZKGQWUZCODZFDZNWVMRABZZDKXZLGTEIWLOHBCLAUXOYCXMSEKHTDXWTXTXVEHKFZBDEFEUXZDEVMSKIHTZTODDCPYMOBOXFZXSNMEYTWMBWUXMWSDODDCNYNBCIMSHDZKEBEYXLBLZEYNVTHBDCRILGUXENXWSCWZNMBLEBNYBMXWVMPYODODCZHZKNNSCVUWAHHTBYTVAHCWXLBLZEYNELXMKIWZNMBLOLKXVHRWKFZTXYANRIWTXQMWSHWZNMBLWTXQDZLGRYVMZCERHEUZVHRDHCODDABZOBHCEZFLDEUZWRVTHBDCCLFQXRLVZDDHEHHXGVDOZLIZSCYUODHZKNNSFEHAIWXLBLNWQCMSHDZKFLOGEBIZWZGIMEWDRNHTZTODNSCSUXBHADHXUGCZXYXHLOADRIAQVCMSBZHEQKXLODNCKNTVYKRYERHTODMSKIMGMESCEBZTODCSMSXRLMCSHLYSXHODNAMEZDGWCNSCHTZTODDCMOGAHVNSNCEMLTXZRWNHNRVXZDZSXLBLVHZEYNWZNMBLMEHYVHHXDHLOODHEXQFADCFKVCMWHEWZNMBLVHAHKOODNSUTXLHTZTODVCFXQCCSZUQWMSXYVMIQTLLABWOLSNNHKQFXLNCRGZDXWZNMBLXVWACSXLBLMEEYUXRCHIEZXHDZELODHCEZLAAHZUWZDXNAWGBZVSXPZDWENZNSQOMOBWGTZTODNSHCEZDHNHKXVHAHRZZESCKXMCEMYFCLKNDHRZRCDXVHMCKNUZFWBZNYYKUXZEKBUTXHCEHXODNSBZODNZHDHTQFRMZDHDCDMSRZFZMWNTNYFAYRDAESRYDVCRADNKUTXLWZNMBLELXMKIRWNTHBHEMCBGCZFACPYXNONWFKZPSFESSYXLBLODHDWUSDEBWZGQAHLOLFMHXZKZNFUXLVODDABZFZOWHEPYAQSEAVHTZTODDCSHMOHFYXVEOGBOVOEKZUODDAUZZULIVHSNFENCMVXFHEODNAHTOYNSHACENPVMFZXHWZNMBLSNLGBWFZXHWZNMBLELXMKIZUBHVHKNUZMEYBVHDIUXMOGACEAGDZLOBWLMMCDEUZODHEUTXFADMOMFMEBVUZELXMKIVHRCZBZDEYXLBLODHDVHBEHEALYSUXZUOWCRFXXLMENTHTIHKZMCKFHTXYOYEZZUXLZPDOZHUICSODCZXYMZMENTEHEBGOKZZWUWHCYXDOVHVTKFAHCKXHODNCFXIHHTODMSKIWUZTZDKFUGCESDEBDHZIYXHEHUYWCSXLBLODNAXLHDODMSKIELHTCVDHYBVHHTXFEZBLMOGBMERILBGZNHZUWVBZODBZCLRZFCNZVCRILVRNBENZVCLTYHUZMEWLHXSIXLBLEZHNNSODMESFWZNMBLEHEBGOZSXLBLZEYNELXMKIWZNMBLADKZLFRIMLRALGGLDENAALXMSMRZZCEKNRAHGQXHODHEMSFDMCSNEVCZXYMZ"

quadscores = {}
floor = None

key = [
    ["I", "Y", "C", "W", "P"],
    ["R", "K", "S", "F", "Q"],
    ["X", "T", "Z", "O", "U"],
    ["M", "B", "A", "L", "G"],
    ["N", "D", "E", "H", "V"],
]

oldkey = None
lookup = {}

def initQuadScores():
    global floor
    N = 0
    with open("common_quads.txt", "r") as f:
        for line in f:
            quad, score = line.strip().split(" ")
            quadscores[quad] = int(score)
            N += int(score)
    for quad in quadscores:
        quadscores[quad] = math.log10(float(quadscores[quad])/N)
    floor = math.log10(0.01/N)

def updateLookup():
    for i in xrange(5):
        for j in xrange(5):
            lookup[key[i][j]] = (i, j)

def getScore(t):
    score = 0
    for i in xrange(len(t) - 3):
        if t[i:i+4] in quadscores:
            score += quadscores[t[i:i+4]]
        else:
            score += floor
    return score

def shuffleKey():
    random.shuffle(key)
    for i in xrange(5):
        random.shuffle(key[i])
    updateLookup()

def printKey(key):
    for i in xrange(5):
        print " ".join(key[i])

def swapKey():
    global oldkey
    oldkey = copy.deepcopy(key)
    i1 = random.randint(0, 4)
    j1 = random.randint(0, 4)
    i2 = random.randint(0, 4)
    j2 = random.randint(0, 4)
    tmp = key[i1][j1]
    key[i1][j1] = key[i2][j2]
    key[i2][j2] = tmp
    lookup[key[i1][j1]] = (i1, j1)
    lookup[key[i2][j2]] = (i2, j2)

def reverseSwapKey():
    global key
    key = oldkey
    updateLookup()

def findSubstitution(c1, c2):
    i1 = lookup[c1]
    i2 = lookup[c2]
    if i1[0] != i2[0] and i1[1] != i2[1]:
        n1 = key[i1[0]][i2[1]]
        n2 = key[i2[0]][i1[1]]
        return n1 + n2
    elif i1[0] == i2[0] and i1[1] != i2[1]:
        n1 = key[i1[0]][(i1[1] - 1) % 5]
        n2 = key[i2[0]][(i2[1] - 1) % 5]
        return n1 + n2
    elif i1[0] != i2[0] and i1[1] == i2[1]:
        n1 = key[(i1[0] - 1) % 5][i1[1]]
        n2 = key[(i2[0] - 1) % 5][i2[1]]
        return n1 + n2

def decryptCipher(t):
    n = ""
    for (c1, c2) in izip(islice(t, 0, None, 2), islice(t, 1, None, 2)):
        n += findSubstitution(c1, c2)
    return n

initQuadScores()
#updateLookup()
shuffleKey()

n = decryptCipher(CIPHER_TEXT)
bestScore = getScore(n)
bestKey = copy.deepcopy(key)
bestText = n
while True:
    T = 20
    while T >= 0:
        for count in xrange(10000):
            swapKey()
            n = decryptCipher(CIPHER_TEXT)

            newScore = getScore(n)
            dF = newScore - bestScore
            if dF >= 0:
                bestScore = newScore
                bestText = n
                bestKey = copy.deepcopy(key)
            elif T > 0:
                if random.random() < math.exp(dF/T):
                    bestScore = newScore
                    bestText = n
                    bestKey = copy.deepcopy(key)
                else:
                    reverseSwapKey()
        print T, bestScore
        printKey(bestKey)
        print bestText
        T -= 0.2
